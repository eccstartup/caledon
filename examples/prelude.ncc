---------------
-- builtins ---
---------------
defn char : prop  -- builtin

defn putChar    :  char -> prop -- builtin
   | putCharImp = [A] putChar A

-- for sequencing io actions
fixity left 1 ,
defn io : prop
   | do = io
   | ,  = io -> prop -> io 

defn run : io -> prop
  >| runDo = run do
  >| runSeq = run (A , B) <- run A 
                          <- B

defn readLine    : (string -> io) -> prop -- builtin 
   | readLineImp = [Foo : string -> io] [A : string] readLine Foo <- run (Foo A)


defn string : prop
  as list char

---------------
-- searches ---
---------------
defn any : (A -> prop) -> prop
   | is = [V : A][F : A -> prop] F V -> any F


defn openAny : [A][F : A -> prop] any F -> [V : A] F V -> prop
   | openAnyDef = openAny A F (is V F FV) V FV

defn sopen : {A : prop }{F : A -> prop} [V : A] {FV : F V} (exists v : A . F v) -> prop 
  as ?\A : prop . ?\ F : A -> prop . \vt : A . ?\ FV : F vt . \an : (exists v : A . F v) . open A F an vt FV


fixity lambda free
defn free : [A : prop] (A -> prop) -> prop
  as \a : prop . any { A = a }

--------------------------
--- useful combinators ---
--------------------------
fixity right 0 $
defn $ : {AT BT : prop } (AT -> BT) -> AT -> BT
  as ?\ AT BT . \ f . \a . f a


fixity right 0 @
defn @ : {AT BT CT:prop} (BT -> CT) -> (AT -> BT) -> AT -> CT
  as ?\AT BT CT : prop . \f : BT -> CT . \ g : AT -> BT . \ a : AT . f (g a)

defn flip : {AT BT CT : prop} (AT -> BT -> CT) -> BT -> AT -> CT
  as ?\ AT BT CT : prop . \ foo . \ b . \ a . foo a b

-------------------
--- Constraints ---
-------------------
fixity none 5 =:=
defn =:= : Q -> Q -> prop
  >| eq = (=:=) {Q = A} B B


-- searching for these is SLOW
fixity none 0 /\
defn /\ : prop -> prop -> prop
  >| and = A -> B -> A /\ B

fixity none 0 \/
defn \/ : prop -> prop -> prop
   | or1 = A -> A \/ B
   | or2 = B -> A \/ B

fixity left 0 ==
-- currently we can't do any inference inside of definitional signatures
defn == : {q : prop} (q -> prop) -> q -> prop 
  as ?\q . \foo : q -> prop . \v : q . foo v


--------------
--- concat ---
--------------
defn concatable : [M : prop] (M -> M -> M -> prop) -> prop
   | concatableNat = concatable natural add
   | concatableList = [A] concatable (list A) concatList


-- it correctly infers 169, and M (but it eta expands Foo when it infers it) !!
fixity right 3 ++
defn ++ : {M}{Foo}{cm : concatable M Foo} M -> M -> M -> prop
  >| ppimp = [M][Foo : M -> M -> M -> prop][M1 M2 M3 : M] 
              (++) {Foo = Foo} M1 M2 M3 
            <- concatable M Foo 
            <- Foo M1 M2 M3 

-------------
--- Order ---
-------------
defn orderable : [M : prop] (M -> M -> prop) -> prop
  >| orderableNatural = orderable natural lte-nat

fixity right 3 =< 
defn =< : {M : prop}{Foo: M -> M -> prop}{co : orderable M Foo} M -> M -> prop
  >| ooimp = [M][Foo : M -> M -> prop] [M1 M2 : M] 
           (=<) {M = M} M1 M2 
          <- orderable M Foo
          <- Foo M1 M2

---------------------
--- Unary Numbers ---
---------------------
defn natural  : prop
   | zero = natural
   | succ = natural -> natural

query findSat0 = free A : natural . A =:= zero

defn add   : natural -> natural -> natural -> prop
  >| add_z = add zero N N
  >| add_s = add N M R -> add (succ N) M (succ R)

query add0 = add (succ zero) zero (succ zero)

query add1 = succ zero ++ zero == succ zero

-- sub N M R is N - M = R
defn sub   : natural -> natural -> natural -> prop
   | sub_by_add = sub N M R <- add M R N


defn lte-nat : natural -> natural -> prop
  >| leqZero = {B} lte-nat zero B
  >| leqSucc = {A B} lte-nat (succ A) (succ B) <- lte-nat A B

fixity none 3 <
defn < : natural -> natural -> prop
  >| ltZero = zero < succ B
  >| ltSucc = succ A < succ B <- A < B

query add2 = exists A : natural . add (succ zero) zero A

query add3 = any $ add (succ zero) zero

query findSat1 = succ zero =< succ (succ zero)

query findSat2 = succ zero =< succ (succ zero) /\ zero =< succ (succ zero)

-------------
--- Maybe ---
-------------

defn maybe : prop -> prop
   | nothing = {a} maybe a
   | just = {a} a -> maybe a

-------------
--- Lists ---
-------------
defn list : prop -> prop
   | nil  = list A
   | cons = A -> list A -> list A

defn concatList : list A -> list A -> list A -> prop
  >| concatListNil  = concatList {A = T} nil L L
  >| concatListCons = concatList (cons V A) B (cons V C) <- concatList A B C

----------------
--- printing ---
----------------

defn putStr : string -> prop
  >| putStr_Nil = putStr $ nil {A = char}
  >| putStr_Cons = putStr $ cons {A = char} V L
                <- putChar V
                <- putStr L

----------------
--- Booleans ---
----------------
defn bool : prop
   | true = bool
   | false = bool

defn if : bool -> bool
  as \b . b

fixity none 1 |:|
defn |:| : {t:prop} t -> t -> (t -> t -> t) -> t
  as ?\t : prop . \a b : t. \f : t -> t -> t. f a b


fixity none 0 ==>
defn ==> : {A : prop} bool -> ((A -> A -> A) -> A) -> A -> prop
  >| thentrue  = [F: _ -> A] (true ==> F ) (F (\a1 a2 : A . a1) )
  >| thenfalse = [F: _ -> B] (false ==> F) (F (\a1 a2 : B . a2))

defn not : bool -> bool -> prop
  as \zq . if zq ==> false |:| true

defn ismain : prop 
  as run $ do 
         , putStr "hey!\n"
         , readLine (\A . do 
   	 , putStr A
         , putStr "\nbye!\n")

-- query main = ismain

-- switching the direction of the output to be input with unification!
defn readLineIn : string -> prop
  as \S . readLine $ \R . do , S =:= R

