---------------------
--- Unary Numbers ---
---------------------
-- an example of how powerfull the syntax is
infixr 0 |->
defn |-> : [a b: atom] atom
  as \a : atom . \b : atom . [ha : a] b

infixr 1 <-|
defn <-| : [a b: atom] atom
  as \a : atom . \b : atom . b |-> a

infixr 0 |=>
defn |=> : [a b: atom]atom
  as \a : atom . \b : atom . {ha : a} b

infixl 1 <=|
defn <=| : [b a : atom] atom
  as \a : atom . \b : atom . {ha : b} a

infixr 0 $
defn $ : {a b:atom} (a -> b) -> a -> b
  as ?\at bt : atom . \f . \ a : at . f a

---------------------
--- Unary Numbers ---
---------------------
defn natural  : atom
   | zero = natural
   | succ = natural → natural

defn add   : natural -> natural -> natural -> atom
   | add_z = {N} add zero N N
   | add_s = {N}{M}{R} add N M R → add (succ N) M (succ R)

defn sub   : natural -> natural -> natural -> atom
   | sub_with_add = {N}{M}{R} sub N M R <- add N R M

-------------
--- Maybe ---
-------------
defn maybe : atom → atom
   | nothing = {a} maybe a
   | just = {a} a → maybe a

-------------
--- Lists ---
-------------
defn list : atom -> atom
   | nil = {a} list a
   | cons = {a} a -> list a -> list a

defn concatList : {A} list A -> list A -> list A -> atom
   | concatListNil  = {T}{L:list T} concatList nil L L
   | concatListCons = {T}{A B C}{V:T} concatList (cons V A) B (cons V C) <- concatList A B C

----------------
--- Booleans ---
----------------
defn bool : atom
   | true = bool
   | false = bool

defn if : bool -> bool
  as \b . b

infix 1 |:|
defn |:| : {a:atom} a -> a -> (a -> a -> a) -> a
  as ?\t : atom . \a b : t. \f : t -> t -> t. f a b

infix 0 ==>
defn ==> : {a} bool -> ((a -> a -> a) -> a) -> a -> atom
   | thentrue  = [a][f: _ -> a] (true ==> f)  (f $ \A B : a. A)
   | thenfalse = [b][f: _ -> b] (false ==> f) (f $ \A B : b . B)

defn not : bool -> bool -> atom
  as \a . if a ==> false |:| true

-------------------
--- Constraints ---
-------------------
infixr 1 =:=
defn =:= : {a : atom} a -> a -> atom
   | eq = [a : atom] a =:= a

infixr 1 /\
defn /\ : atom -> atom -> atom
   | and = {a b:atom} a -> b -> a /\ b

infixr 1 \/
defn \/ : atom -> atom -> atom
   | or1 = {a b:atom} a -> a \/ b
   | or2 = {a b:atom} b -> a \/ b
