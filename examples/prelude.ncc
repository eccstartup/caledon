---------------
-- searches ---
---------------
defn any : {A : atom} (A -> atom) -> atom
   | is = [A : atom][V : A][F : A -> atom] F V -> any { A = A } F

--------------------------
--- useful combinators ---
--------------------------
infixr 0 $
defn $ : {a b:atom} (a -> b) -> a -> b
  as ?\ at bt . λ f . λ a . f a

infixr 0 @
defn @ : {a b c:atom} (b -> c) -> (a -> b) -> a -> c
  as ?λat bt ct : atom . λf : bt -> ct . λ g : at -> bt . λ a : at . f (g a)

defn flip : {a b c : atom} (a -> b -> c) -> b -> a -> c
  as ?λ at bt ct : atom . λ foo . λ b . λ a . foo a b


-------------------
--- Constraints ---
-------------------
infix 1 =:=
defn =:= : {q} q -> q -> atom
   | eq = [a : atom][b:a] (=:=) {q = a} b b

-- searching for these is SLOW
infix 0 /\
defn /\ : atom -> atom -> atom
   | and = [a b:atom] a -> b -> a /\ b

infix 0 \/
defn \/ : atom -> atom -> atom
   | or1 = [a b:atom] a -> a \/ b
   | or2 = [a b:atom] b -> a \/ b

--------------
--- concat ---
--------------
defn concatable : atom -> atom
   | concatableImp = [M] (M -> M -> M -> atom) -> concatable M

infixr 3 ++
defn ++ : {M} {cm : concatable M} M -> M -> M -> atom
   | ppimp = [M][Foo : M -> M -> M -> atom][M1 M2 M3 : M] (++) {M = M} {cm = concatableImp M Foo} M1 M2 M3 <- Foo M1 M2 M3


-------------
--- Order ---
-------------

defn orderable : atom -> atom
   | orderableImp = [M] (M -> M -> atom) -> orderable M

infixr 3 ≤ 
defn ≤ : {M} {cm : orderable M} M -> M -> atom
   | ooimp = [M][Foo : M -> M -> atom][M1 M2 : M] (≤) {M = M} {cm = orderableImp M Foo} M1 M2 <- Foo M1 M2

infix 2 ≥
defn ≥ : {M : atom} {cm : orderable M} M -> M -> atom
  as ?\M . ?\ cm : orderable M . \M1 M2 : M . M2 ≤ M1

---------------------
--- Unary Numbers ---
---------------------
defn natural  : atom
   | zero = natural
   | succ = natural → natural

defn add   : natural -> natural -> natural -> atom
   | add_z = [N] add zero N N
   | add_s = [N M R] add N M R -> add (succ N) M (succ R)

-- sub N M R is N - M = R
defn sub   : natural -> natural -> natural -> atom
   | sub_by_add = [N M R] sub N M R <- add M R N

defn concatableNatural : concatable natural
  as concatableImp natural add

defn lte-nat : natural -> natural -> atom
   | leqZero = [B] lte-nat zero B
   | leqSucc = [A B] lte-nat (succ A) (succ B) <- lte-nat A B

infix 3 <
defn < : natural -> natural -> atom
   | ltZero = [B] zero < succ B
   | ltSucc = [A B] succ A < succ B <- A < B

defn orderableNatural : orderable natural
  as orderableImp natural lte-nat
{-
query findSat1 = exists A . A =:= zero

query add1 = (++) (succ zero) zero (succ zero)

query add2 = exists A : natural . add (succ zero) zero A

query add3 = any $ add (succ zero) zero

query findSat2 = succ zero ≤ succ (succ zero) /\ succ zero ≤ succ zero

defn pred : natural -> atom
   | predimp = [A : natural] zero < A -> A < succ (succ zero) -> pred A

query findSat3 = exists A: natural.  pred A

-}
-------------
--- Maybe ---
-------------
defn maybe : atom → atom
   | nothing = {a} maybe a
   | just = {a} a → maybe a

-------------
--- Lists ---
-------------
defn list : atom -> atom
   | nil  = {a} list a
   | cons = {a} a -> list a -> list a

defn concatList : {A} list A -> list A -> list A -> atom
   | concatListNil  = [T][L:list T] concatList {A = T} nil L L
   | concatListCons = [T][A B C : list T][V:T] concatList (cons V A) B (cons V C) <- concatList A B C

defn concatableList : {A:atom} concatable (list A)
  as ?λA . concatableImp (list A) concatList

----------------
--- Booleans ---
----------------
defn bool : atom
   | true = bool
   | false = bool

defn if : bool -> bool
  as λb . b

infix 1 |:|
defn |:| : {a:atom} a -> a -> (a -> a -> a) -> a
  as ?λt : atom . λa b : t. λf : t -> t -> t. f a b


infix 0 ==>
defn ==> : {a : atom} bool -> ((a -> a -> a) -> a) -> a -> atom
   | thentrue  = [a : atom][f: _ -> a] (true ==> f)  (f (λA B : a. A))
   | thenfalse = [b : atom][f: _ -> b] (false ==> f) (f (λA B : b . B))

defn not : bool -> bool -> atom
  as λa . if a ==> false |:| true





----------------------
--- Binomial heaps ---
----------------------
defn count-list : (natural -> atom) -> natural -> atom
   | cl-nil = {V } count-list V zero
   | cl-cons = {R}{V} V R -> count-list V R -> count-list V (succ R)

defn binomial-tree : atom {- elements -} -> natural {- rank -} -> atom
   | binomial-node = {A}{R} A -> count-list (binomial-tree A) R -> binomial-tree A R

defn binomial-heap : atom -> atom
  as λa : atom . any $ count-list $ maybe @ binomial-tree a

defn tree-merge : {R: natural}{M : atom}{cm : orderable M} binomial-tree M R -> binomial-tree M R -> binomial-tree M (succ R) -> atom
   | tree-merge-ord-lt = [R: natural][M : atom][a a' : M][bl b'l : count-list (binomial-tree M) R][cm : orderable M] 
-- curiously enough, switching cons makes this easier to infer!
          		 tree-merge (binomial-node a bl) (binomial-node a' b'l)  (binomial-node a (cl-cons (binomial-node a' b'l) bl))
	   	      <- a ≤ a'
{-
   | tree-merge-ord-gt = [R : natural][M : atom][a a' : M][bl b'l][cm : orderable M] 
          		 tree-merge (binomial-node a bl) (binomial-node a' b'l)  (binomial-node a' $ cl-cons {R = R} b'l (binomial-node a bl))
	   	      <- a' ≤ a

-}