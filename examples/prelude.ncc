---------------
-- searches ---
---------------

defn findOne : {A : atom} (A -> atom) -> atom
   | found   = [A : atom][V : A][F : A -> atom] F V -> findOne { A = A } F

---------------------
--- Unary Numbers ---
---------------------
infixr 0 $
defn $ : {a b:atom} (a -> b) -> a -> b
  as ?\at bt : atom . \f . \ a : at . f a

--------------
--- concat ---
--------------
defn concatable : atom -> atom
   | concatableImp = [M] (M -> M -> M -> atom) -> concatable M

infixr 3 ++
defn ++ : {M} {cm : concatable M} M -> M -> M -> atom
   | ppimp = [M][Foo : M -> M -> M -> atom][M1 M2 M3 : M] (++) {M = M} {cm = concatableImp M Foo} M1 M2 M3 <- Foo M1 M2 M3

---------------------
--- Unary Numbers ---
---------------------
defn natural  : atom
   | zero = natural
   | succ = natural → natural

defn add   : natural -> natural -> natural -> atom
   | add_z = [N] add zero N N
   | add_s = [N][M][R] add N M R -> add (succ N) M (succ R)

defn concatableNatural : concatable natural
  as concatableImp natural add

query addOne = (++) (succ zero) zero (succ zero)

query addTwo = exists A : natural . add (succ zero) zero A

query addThree = findOne $ add (succ zero) zero


defn sub   : natural -> natural -> natural -> atom
   | sub_with_add = {N}{M}{R} sub N M R <- add N R M

-------------
--- Maybe ---
-------------
defn maybe : atom → atom
   | nothing = {a} maybe a
   | just = {a} a → maybe a

-------------
--- Lists ---
-------------
defn list : atom -> atom
   | nil  = {a} list a
   | cons = {a} a -> list a -> list a

defn concatList : {A} list A -> list A -> list A -> atom
   | concatListNil  = [T][L:list T] concatList {A = T} nil L L
   | concatListCons = [T][A B C : list T][V:T] concatList (cons V A) B (cons V C) <- concatList A B C


defn concatableList : {A:atom} concatable (list A)
  as ?\A . concatableImp (list A) concatList

----------------
--- Booleans ---
----------------
defn bool : atom
   | true = bool
   | false = bool

defn if : bool -> bool
  as \b . b

infix 1 |:|
defn |:| : {a:atom} a -> a -> (a -> a -> a) -> a
  as ?\t : atom . \a b : t. \f : t -> t -> t. f a b


infix 0 ==>
defn ==> : {a} bool -> ((a -> a -> a) -> a) -> a -> atom
   | thentrue  = [a : atom][f: _ -> a] (true ==> f)  (f $ \A B : a. A)
   | thenfalse = [b][f: _ -> b] (false ==> f) (f $ \A B : b . B)

defn not : bool -> bool -> atom
  as \a . if a ==> false |:| true

-------------------
--- Constraints ---
-------------------
infixr 1 =:=
defn =:= : {a : atom} a -> a -> atom
   | eq = [a : atom] a =:= a

infixr 1 /\
defn /\ : atom -> atom -> atom
   | and = {a b:atom} a -> b -> a /\ b

infixr 1 \/
defn \/ : atom -> atom -> atom
   | or1 = {a b:atom} a -> a \/ b
   | or2 = {a b:atom} b -> a \/ b
