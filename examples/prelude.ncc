---------------
-- builtins ---
---------------
defn char : atom  -- builtin

defn putChar    :  char -> atom -- builtin
   | putCharImp = [A] putChar A

-- for sequencing io actions
fixity left 1 ,
defn io : atom
   | do = io
   | ,  = io -> atom -> io 

defn run : io -> atom
   | runDo = run do
   | runSeq = [A][B] run (A , B) <- run A 
                         	 <- B

defn readLine    : (string -> io) -> atom -- builtin 
   | readLineImp = [Foo : string -> io] [A : string] readLine Foo <- run (Foo A)

defn string : atom
  as list char

---------------
-- searches ---
---------------
defn any : {A : atom} (A -> atom) -> atom
   | is = [A : atom][V : A][F : A -> atom] F V -> any { A = A } F

defn openAny : [A][F : A -> atom] any F -> [V : A] F V -> atom
   | openAnyDef = [A][F : A -> atom][V : A][FV : F V] openAny A F (is A V F FV) V FV

defn sopen : {A : atom }{F : A -> atom} [V : A] F V => (exists v : A . F v) -> atom 
  as ?\a : atom . ?\ f : a -> atom . \vt : a . ?\ fv : f vt . \an : (exists v : a . f v) . open a f an vt fv

fixity lambda findOne
defn findOne : [A : atom] (A -> atom) -> atom
  as \a: atom . any { A = a }

--------------------------
--- useful combinators ---
--------------------------
fixity right 0 $
defn $ : {a b:atom} (a -> b) -> a -> b
  as ?\ at bt . \ f . \a . f a


fixity right 0 @
defn @ : {a b c:atom} (b -> c) -> (a -> b) -> a -> c
  as ?\at bt ct : atom . \f : bt -> ct . \ g : at -> bt . \ a : at . f (g a)

defn flip : {a b c : atom} (a -> b -> c) -> b -> a -> c
  as ?\ at bt ct : atom . \ foo . \ b . \ a . foo a b


-------------------
--- Constraints ---
-------------------
fixity none 1 =:=
defn =:= : {q} q -> q -> atom
   | eq = [a : atom][b:a] (=:=) {q = a} b b

-- searching for these is SLOW
fixity none 0 /\
defn /\ : atom -> atom -> atom
   | and = [a b : atom] a -> b -> a /\ b

fixity none 0 \/
defn \/ : atom -> atom -> atom
   | or1 = [a b:atom] a -> a \/ b
   | or2 = [a b:atom] b -> a \/ b

fixity left 0 ==
-- currently we can't do any inference inside of definitional signatures
defn == : {q : atom} (q -> atom) -> q -> atom 
  as ?\q . \foo : q -> atom . \v : q . foo v


--------------
--- concat ---
--------------
defn concatable : [M : atom] (M -> M -> M -> atom) -> atom
   | concatableNat = concatable natural add
   | concatableList = [A] concatable (list A) concatList


-- it correctly infers 169, and M (but it eta expands Foo when it infers it) !!
fixity right 3 ++
defn ++ : {M}{Foo}{cm : concatable M Foo} M -> M -> M -> atom
   | ppimp = [M][Foo : M -> M -> M -> atom][M1 M2 M3 : M] 
              (++) {Foo = Foo} M1 M2 M3 
            <- concatable M Foo 
            <- Foo M1 M2 M3 

-------------
--- Order ---
-------------
defn orderable : [M : atom] (M -> M -> atom) -> atom
   | orderableNatural = orderable natural lte-nat

fixity right 3 =< 
defn =< : {M : atom}{Foo: M -> M -> atom}{co : orderable M Foo} M -> M -> atom
   | ooimp = [M][Foo : M -> M -> atom] [M1 M2 : M] 
           (=<) {M = M} M1 M2 
          <- orderable M Foo
          <- Foo M1 M2

---------------------
--- Unary Numbers ---
---------------------
defn natural  : atom
   | zero = natural
   | succ = natural -> natural

query findSat0 = exists A . A =:= zero

defn add   : natural -> natural -> natural -> atom
   | add_z = [N] add zero N N
   | add_s = [N M R] add N M R -> add (succ N) M (succ R)

query add0 = add (succ zero) zero (succ zero)

query add1 = succ zero ++ zero == succ zero

-- sub N M R is N - M = R
defn sub   : natural -> natural -> natural -> atom
   | sub_by_add = [N M R] sub N M R <- add M R N


defn lte-nat : natural -> natural -> atom
   | leqZero = [B] lte-nat zero B
   | leqSucc = [A B] lte-nat (succ A) (succ B) <- lte-nat A B

fixity none 3 <
defn < : natural -> natural -> atom
   | ltZero = [B] zero < succ B
   | ltSucc = [A B] succ A < succ B <- A < B

query add2 = exists A : natural . add (succ zero) zero A

query add3 = any $ add (succ zero) zero

query findSat1 = succ zero =< succ (succ zero)

query findSat2 = succ zero =< succ (succ zero) /\ zero =< succ (succ zero)

-------------
--- Maybe ---
-------------

defn maybe : atom -> atom
   | nothing = {a} maybe a
   | just = {a} a -> maybe a

-------------
--- Lists ---
-------------
defn list : atom -> atom
   | nil  = {a} list a
   | cons = {a} a -> list a -> list a

defn concatList : {A} list A -> list A -> list A -> atom
   | concatListNil  = [T][L:list T] concatList {A = T} nil L L
   | concatListCons = [T][A B C : list T][V:T] concatList (cons V A) B (cons V C) <- concatList A B C

----------------
--- printing ---
----------------

defn putStr : string -> atom
   | putStr_Nil = putStr $ nil {a = char}
   | putStr_Cons = [v:char][l: string] 
                   putStr $ cons {a = char} v l 
                <- putChar v
                <- putStr l

----------------
--- Booleans ---
----------------
defn bool : atom
   | true = bool
   | false = bool

defn if : bool -> bool
  as \b . b

fixity none 1 |:|
defn |:| : {a:atom} a -> a -> (a -> a -> a) -> a
  as ?\t : atom . \a b : t. \f : t -> t -> t. f a b


fixity none 0 ==>
defn ==> : {a : atom} bool -> ((a -> a -> a) -> a) -> a -> atom
   | thentrue  = [a : atom][f: _ -> a] (true ==> f)  (f (\A B : a. A))
   | thenfalse = [b : atom][f: _ -> b] (false ==> f) (f (\A B : b . B))

defn not : bool -> bool -> atom
  as \a . if a ==> false |:| true

query main = run $ do 
                 , putStr "hey!\n"
	  	 , readLine ( \A . do 
   		 , putStr A
                 , putStr "\nbye!\n")

