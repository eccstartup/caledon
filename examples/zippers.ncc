fixity left 1 +
fixity left 2 *
fixity left 4 ^

defn zero : prop 
  as [A : prop] A

defn fromZero : zero -> A
  as ?\ A : prop . 
      \ z : zero .
        z A

defn one : prop
  as [A : prop] A -> A

defn unit : one
  as \ A : prop . 
     \ x : A . x

defn caseUnit : (one -> A) -> A
  as ?\ A   : prop     .
      \ foo : one -> A .
        foo unit

defn neg : prop -> prop
  as \ A : prop . [C : prop] A -> C

defn ^ : prop -> prop -> prop
  as \ A B : prop . A -> B

defn + : prop -> prop -> prop
  as \ A B : prop . 
      {C : prop} (A -> C) -> (B -> C) -> C

defn case : At + Bt -> (At -> Ct) -> (Bt -> Ct) -> Ct
  as ?\ At Bt Ct : prop   .
      \ sum    : At + Bt  .
      \ inl    : At -> Ct .
      \ inr    : Bt -> Ct .
        sum { C = Ct } inl inr

defn inL : A -> A + B
  as ?\ A B : prop   .
      \ a   : A      .
     ?\ C   : prop   .
      \ inl : A -> C .
      \ inr : B -> C .
        inl a

defn inR : {A B} B -> A + B
  as ?\ A B : prop   .
      \ b   : B      .
     ?\ C   : prop   .
      \ inl : A -> C .
      \ inr : B -> C .
        inr b

defn * : prop -> prop -> prop
  as \ A B : prop . 
      [C : prop] (A -> B -> C) -> C

defn pair : A -> B -> A * B
  as ?\ A B : prop        .
      \ a   : A           .
      \ b   : B           .
      \ C   : prop        .
      \ pi  : A -> B -> C . 
        pi a b

defn piL : A * B -> A
  as ?\ A B  : prop  .
      \ prod : A * B . 
        prod A (\a : A . \ b : B . a)

defn piR : A * B -> B
  as ?\ A B  : prop  .
      \ prod : A * B . 
        prod B (\a : A . \ b : B . b)



defn eq : prop -> prop -> prop
   | eq-sym = eq Av Av
   
   | eq-add-ident = eq (Av + neg Av) zero

   | eq-zero-pow = eq (Av ^ zero ) one
   | eq-one-pow = eq (Av ^ one ) Av

   | eq-zero-mult = eq (Av * zero) zero
   | eq-one-mult = eq (Av * one) Av

   | eq-zero-add = eq (Av + zero) Av

   | eq-exp = eq (Av ^ (Bv + Cv)) (Av ^ Bv * Av ^ Cv)

   | eq-sym-plus = eq (Av + Bv) (Bv + Av)
   | eq-sym-times = eq (Av * Bv) (Bv * Av)

   | eq-plus-times-trans = eq (Av * (Bv + Cv)) (Av * Bv + Av * Cv)
   | eq-plus-trans = eq (Av + (Bv + Cv)) ((Av + Bv) + Cv)
   | eq-times-trans = eq (Av * (Bv * Cv)) ((Av * Bv) * Cv)
 
   | eq-plus = eq (Av + Bv) (Av' + Bv') <- eq Av Av' <- eq Bv Bv'
   | eq-prod = eq (Av * Bv) (Av' * Bv') <- eq Av Av' <- eq Bv Bv'
   | eq-pow  = eq (Av ^ Bv) (Av' ^ Bv') <- eq Av Av' <- eq Bv Bv'
   
   | eq-refl = eq Av Bv <- eq Bv Av
   
   | eq-imp = eq A B 
           <- (A -> B) 
           <- (B -> A)


defn deriv : (prop -> prop) -> (prop -> prop) -> prop
  >| deriv-one = deriv (\x . x ) (\ x . one)
  >| deriv-const = deriv (\ x . R) (\ x . zero)

  >| deriv-sum  = deriv (\ x . A x + B x) (\ x . A' x + B' x)
               <- deriv A A'
               <- deriv B B'
  >| deriv-prod = deriv (\ x . U x * V x) (\ x . U' x * V x + U x * V' x)
               <- deriv V V'
               <- deriv U U'

  >| deriv-pow = deriv (\ x . U x ^ (one + R) ) (\ x . U' x * (one + R) * U x ^ R)
              <- deriv U U' 

   | deriv-eq  = deriv A B 
               <- ([x] eq (A x) (A' x))
               <- ([x] eq (B x) (B' x))
               <- deriv A' B'